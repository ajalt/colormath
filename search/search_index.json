{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting Started","text":"<p>Colormath is a Kotlin Multiplatform library for color manipulation and conversion.</p> <p>Colormath can:</p> <ul> <li>Convert between color models and spaces</li> <li>Manipulate colors with transformations such as mixing and chromatic adaptation</li> <li>Calculate attributes such as WCAG contrast and perceptual color difference</li> <li>Generate gradients with custom interpolation methods and easing functions</li> <li>Parse and render colors as strings, including all representations from the CSS spec</li> </ul> <pre><code>// Create an sRGB color\nval color = RGB(\"#ff23cc\")\n\n// Interpolate with another color\nval mixed = color.interpolate(RGB(0.1, 0.4, 1), 0.5f)\n// RGB(\"#8c45e6\")\n\n// Convert to a different color space\nval lab = mixed.toLAB()\n// LAB(46.3, 60.9, -70)\n\n// Change the transparency\nval labA = lab.copy(alpha = 0.25f)\n// LAB(46.3, 60.9, -70, 0.25)\n\n// Adapt white point\nval lab50 = labA.convertTo(LAB50)\n// LAB50(45, 55.1812, 72.5911, 0.25)\n\n// Render as a css color string\nprintln(lab50.formatCssString())\n// \"lab(45% 55.1812 -72.5911 / 0.25)\"\n</code></pre>"},{"location":"changelog/","title":"Releases","text":""},{"location":"changelog/#360","title":"3.6.0","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>Publish artifacts for the <code>watchosArm32</code> target (thanks @ReneeVandervelde)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Update Kotlin to 2.0.0</li> </ul>"},{"location":"changelog/#350","title":"3.5.0","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>Publish artifacts for the <code>JS</code> and <code>wasmJs</code> targets for the jetpack-compose extensions.</li> <li>Added support to <code>formatCssString</code> and <code>Color.parse</code> for color spaces added in recent updates to the CSS color spec: <code>oklab</code>, <code>oklch</code>, <code>srgb-linear</code>, <code>xyz-d50</code> and <code>xyz-d65</code>. </li> <li>Added <code>customColorSpaces</code> for <code>Color.parse</code> and <code>Color.formatCssString</code> to allow non-standard color spaces to be used in color strings.</li> <li>Added <code>min</code> and <code>max</code> properties to <code>ColorComponentInfo</code> to get the reference range for the component.</li> <li>Support percentage format for all values in <code>Color.parse</code> with reference range scaling from the new drafts of CSS Color Module 4.</li> <li>Added <code>clamp()</code> function to all color models to clamp the color components to their valid range.</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li><code>Color.parse</code> now parses <code>lch()</code> and <code>lab()</code> functions with the with D50 white points instead of D65 in order to comply with the latest draft of CSS Color Module 4.</li> <li><code>Color.parse</code> no longer clamps out-of-gamut values by default. Use the new <code>clamp</code> method on the returned color if desired.</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li><code>ColorSpace.equals</code> will now properly return true when comparing color companions with the space they represent e.g. <code>XYZ == XYZ65</code></li> <li>Support the CSS \u201cnone\u201d keyword for <code>NaN</code> values in <code>Color.parse</code> and <code>Color.formatCssString</code> </li> </ul>"},{"location":"changelog/#340","title":"3.4.0","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>Publish artifacts for the <code>wasmJs</code> target. This target is experimental.</li> </ul>"},{"location":"changelog/#333","title":"3.3.3","text":""},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>Use unique namespace for all android extensions and disable BuildConfig generation. Thanks to @frett for the contribution (#45)</li> </ul>"},{"location":"changelog/#332","title":"3.3.2","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>Publish <code>linuxArm64</code> target. This target is not tested on CI.</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.9.0</li> </ul>"},{"location":"changelog/#331","title":"3.3.1","text":""},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>Publish JVM artifacts with Java 8 bytecode</li> </ul>"},{"location":"changelog/#330","title":"3.3.0","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>The core module now publishes multiplatform targets for <code>iosSimulatorArm64</code>, <code>tvosSimulatorArm64</code>, and <code>watchosSimulatorArm64</code>. </li> <li>The Jetpack Compose extensions module <code>colormath-ext-jetpack-compose</code> now publishes multiplatform targets for JVM and iOS in addition to the existing android target.</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.8</li> </ul>"},{"location":"changelog/#321","title":"3.2.1","text":""},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.7.10</li> </ul>"},{"location":"changelog/#320","title":"3.2.0","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li><code>hueOr</code> extension to colors like <code>HSV</code> that returns the color\u2019s hue or a fallback value if the hue is undefined.</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.6.0</li> </ul>"},{"location":"changelog/#311","title":"3.1.1","text":""},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>Fix shared immutability for background threads on Kotlin Native</li> </ul>"},{"location":"changelog/#310","title":"3.1.0","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>Optional modules with extensions for converting between Colormath colors and other platform representations.</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>Unspecified alpha values now default to fully opaque</li> </ul>"},{"location":"changelog/#300","title":"3.0.0","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>New color models: <code>Oklab</code>, <code>Oklch</code>, <code>HWB</code>, <code>HPLuv</code>, <code>HSLuv</code>, <code>LCHab</code>, <code>LCHuv</code>, <code>JzAzBz</code>, <code>JzCzHz</code>, <code>ICtCp</code></li> <li>New RGB color spaces: <code>Linear sRGB</code>, <code>ACES</code>, <code>ACEScc</code>, <code>ACEScct</code>, <code>ACEScg</code>, <code>Adobe RGB</code>, <code>BT.2020</code>, <code>BT.709</code>, <code>DCI P3</code>, <code>Display P3</code>, <code>ProPhoto</code></li> <li>Other color spaces: <code>LABColorSpace</code>, <code>LCHabColorSpace</code>, <code>LCHuvColorSpace</code>, <code>LUVColorSpace</code>, <code>XYZColorSpace</code></li> <li>WCAG contrast: <code>wcagLuminance</code>, <code>wcagContrastRatio</code>, <code>mostContrasting</code>, <code>firstWithContrast</code></li> <li>Color difference: <code>euclideanDistance</code>, <code>differenceCIE76</code>, <code>differenceCIE94</code>, <code>differenceCIE2000</code>, <code>differenceCMC</code>, <code>differenceEz</code></li> <li>Transforms: <code>Color.map</code>, <code>mix</code>, <code>multiplyAlpha</code>, <code>divideAlpha</code>, <code>createChromaticAdapter</code>, <code>RGBColorSpace.converterTo</code></li> <li>Interpolation: <code>Color.interpolate</code>, <code>ColorSpace.interpolator</code></li> <li>Color metadata: <code>ColorSpace</code>, <code>Color.space</code>, <code>Color.toArray</code>, <code>ColorSpace.create</code></li> <li>CSS parsing and rendering now support all CSS color strings</li> <li><code>RGBInt</code>: an inline class that stores <code>RGB</code> colors packed in a single Int. Create instances directly, or convert to it with <code>RGB.toRGBInt()</code></li> <li>Publish <code>macosArm64</code> target.</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>All <code>Color</code> classes now store their color components as <code>Float</code></li> <li><code>RGB</code>, <code>XYZ</code>, HSV<code>,</code>HSL<code>, and</code>HWB<code>now store their rectangular components normalized to</code>[0, 1]`.</li> <li>Renamed <code>Color.fromCss</code> to <code>Color.parse</code>.</li> <li>All <code>Color</code> constructors now use <code>alpha</code> as name of their final parameter.</li> <li>Replace <code>toCssRgb</code> and <code>toCssHsl</code> with <code>fromatCssString</code> that supports all color models.</li> <li>All color models moved from the package <code>com.github.ajalt.colormath</code> to <code>com.github.ajalt.colormath.model</code></li> <li>Updated Kotlin to 1.5.30</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>Removed the previously deprecated <code>ConvertibleColor</code> typealias.</li> <li>Removed the <code>CssColors</code> object. Use <code>Color.fromCss</code> instead. </li> <li>Removed <code>Ansi16</code> companion object color constants.</li> <li>Removed <code>Color.toHex()</code>. Use <code>RGB.toHex()</code> instead.</li> </ul>"},{"location":"changelog/#210","title":"2.1.0","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>Added CIE LUV colorspace support</li> <li>Added CIE LCH(uv) colorspace support</li> <li>Added HWB colorspace support</li> <li>Added <code>lab()</code> and <code>hwb()</code> support to <code>Color.fromCss</code></li> <li>JS target now publishes IR format in addition to legacy jars</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>Updated Kotlin to 1.5.0</li> <li><code>Color.fromCss</code> now clamps out-of-range values in accordance with the CSS Color Module Level 4 spec</li> </ul>"},{"location":"changelog/#200","title":"2.0.0","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>Added multiplatform support.</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>Moved maven coordinates to <code>com.github.ajalt.colormath:colormath:2.0.0</code>.</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Renamed <code>ConvertibleColor</code> to <code>Color</code>. The old name is left as a deprecated type alias.</li> </ul>"},{"location":"changelog/#141","title":"1.4.1","text":""},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>Fix <code>RGB(255,255, 255).toLAB()</code> throwing an exception due to rounding precision.</li> </ul>"},{"location":"changelog/#140","title":"1.4.0","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li><code>hueAsRad()</code>, <code>hueAsGrad()</code>, and <code>hueAsTurns()</code> extensions for <code>HSL</code> and <code>HSV</code> classes.</li> <li><code>toHex()</code> now has a <code>renderAlpha</code> parameter that lets you render the color\u2019s alpha channel in the hex. By default the alpha will be added if it\u2019s &lt; 1.</li> <li><code>toCssRgb()</code> and <code>toCssHsl()</code> extensions to render colors as CSS color functions</li> <li><code>RGB.toPackedInt()</code> to convert a color to a single integer.</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li><code>withNumberSign</code> parameter of <code>toHex</code> now defaults to <code>true</code></li> <li><code>ColorMath.parseCssColor()</code> renamed to <code>ConvertableColor.fromCss()</code> and <code>ColorMath.cssKeywordColors</code> to <code>CssColors.colorsByName</code></li> </ul>"},{"location":"changelog/#130","title":"1.3.0","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>All colors now have an <code>alpha</code> channel, defaulting to 1 (fully opaque). For colorspaces that support transparency, you can pass an alpha value into their constructors.</li> <li><code>ColorMath.parseCssColor()</code> can parse all valid HTML/CSS colors, including rgb, hsl, and named colors.</li> <li><code>ColorMath.cssKeywordColors</code> is a map of HTML/CSS color names to RGB the colors they represent.</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>Switch rounding methods to use <code>kotlin.math</code> rounding, which can slightly change conversion results in some cases.</li> </ul>"},{"location":"changelog/#120","title":"1.2.0","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>Add ability to construct RGB instances from packed integers or Bytes</li> </ul>"},{"location":"colorspaces/","title":"Color Spaces","text":"<p>Colormath has a number of built-in color spaces and models.</p> <p>A note on terminology</p> <p>A color model defines the components of a color. For example, RGB is a color model that defines colors with the additive combination of red, green, and blue light.</p> <p>A color space is a color model plus the details necessary to represent a color in that model. sRGB and DCI P3 are both color spaces the use the RGB model, but they define different values for the exact colors of their RGB primaries.</p>"},{"location":"colorspaces/#built-in-color-models","title":"Built-in color models","text":""},{"location":"colorspaces/#rgb","title":"RGB","text":"<ul> <li>RGB</li> </ul> Component Description Range r red <code>[0, 1]</code> g green <code>[0, 1]</code> b blue <code>[0, 1]</code> <p>The RGB color model defines colors with the additive combination of reg, green, and blue lights. RGB components are stored as floating point numbers in the range <code>[0, 1]</code>. You can also represent sRGB colors as packed integers with RGBInt, or create them from integers in the range <code>[0, 255]</code> with RGB.from255().</p>"},{"location":"colorspaces/#rgb-color-spaces","title":"RGB color spaces","text":"<p>Colormath includes a number of built-in RGB color spaces, and you can define your own with RGBColorSpace. The default RGB space is sRGB.</p> <ul> <li>sRGB</li> <li>Linear sRGB</li> <li>ACES</li> <li>ACEScc</li> <li>ACEScct</li> <li>ACEScg</li> <li>Adobe RGB</li> <li>BT.2020 / REC.2020</li> <li>BT.709 / REC.709</li> <li>DCI P3</li> <li>Display P3</li> <li>ROMM RGB / ProPhoto RGB</li> </ul>"},{"location":"colorspaces/#hsl","title":"HSL","text":"<ul> <li>HSL</li> </ul> Component Description Range h hue, degrees, <code>NaN</code> for monochrome colors <code>[0, 360)</code> s saturation <code>[0, 1]</code> l lightness <code>[0, 1]</code> <p>A cylindrical representation of sRGB using Hue, Saturation, and Lightness.</p>"},{"location":"colorspaces/#hsv","title":"HSV","text":"<ul> <li>HSV</li> </ul> Component Description Range h hue, degrees, <code>NaN</code> for monochrome colors <code>[0, 360)</code> s saturation <code>[0, 1]</code> v value <code>[0, 1]</code> <p>A cylindrical representation of sRGB using Hue, Saturation, and Value / brightness.</p>"},{"location":"colorspaces/#hwb","title":"HWB","text":"<ul> <li>HWB</li> </ul> Component Description Range h hue, degrees <code>[0, 360)</code> w whiteness <code>[0, 1]</code> b blackness <code>[0, 1]</code> <p>A cylindrical representation of sRGB using Hue, Whiteness, and Blackness.</p>"},{"location":"colorspaces/#hsluv-and-hpluv","title":"HSLuv and HPLuv","text":"<ul> <li>HSLuv</li> </ul> Component Description Range h hue, degrees, <code>NaN</code> for monochrome colors <code>[0, 360)</code> s saturation <code>[0, 100]</code> l lightness <code>[0, 100]</code> <ul> <li>HPLuv</li> </ul> Component Description Range h hue, degrees, <code>NaN</code> for monochrome colors <code>[0, 360)</code> p percentage saturation <code>[0, 100]</code> l lightness <code>[0, 100]</code> <p>HSLuv and HPLuv are color spaces designed as a human friendly alternative to HSL.</p>"},{"location":"colorspaces/#ictcp","title":"IC<sub>t</sub>C<sub>p</sub>","text":"<ul> <li>ICtCp</li> </ul> Component Description Range I intensity <code>[0, 1]</code> C<sub>t</sub> Tritan (blue-yellow) <code>[-0.5, 0.5]</code> C<sub>p</sub> Protan (red-green) <code>[-0.5, 0.5]</code> <p>IC<sub>t</sub>C<sub>p</sub> is a color space designed for high dynamic range and wide color gamut imagery.</p>"},{"location":"colorspaces/#jzazbz-and-jzczhz","title":"J<sub>z</sub>A<sub>z</sub>B<sub>z</sub> and J<sub>z</sub>C<sub>z</sub>H<sub>z</sub>","text":"<ul> <li>JzAzBz</li> </ul> Component Description Range J<sub>z</sub> lightness <code>[0, 1]</code> A<sub>z</sub> green-red <code>[-1, 1]</code> B<sub>z</sub> blue-yellow <code>[-1, 1]</code> <ul> <li>JzCzHz</li> </ul> Component Description Range J<sub>z</sub> lightness <code>[0, 1]</code> C<sub>z</sub> chroma <code>[-1, 1]</code> H<sub>z</sub> hue, degrees, <code>NaN</code> for monochrome colors <code>[0, 360)</code> <p>J<sub>z</sub>A<sub>z</sub>B<sub>z</sub> is a perceptually uniform space where euclidean distance predicts perceptual difference. J<sub>z</sub>C<sub>z</sub>H<sub>z</sub> is its cylindrical representation.</p>"},{"location":"colorspaces/#cie-lab-and-lchab","title":"CIE L*a*b* and LCH<sub>ab</sub>","text":"<ul> <li>LAB</li> </ul> Component Description Range L lightness <code>[0, 100]</code> a* green-red <code>[-128, 128]</code> b* blue-yellow <code>[-128, 128]</code> <ul> <li>LCHab</li> </ul> Component Description Range L lightness <code>[0, 100]</code> c chroma <code>[0, 150]</code> h hue, degrees, <code>NaN</code> for monochrome colors <code>[0, 360)</code> <p>LAB is a color model intended to be perceptually uniform. Its cylindrical representation is LCH<sub>ab</sub>.</p>"},{"location":"colorspaces/#lab-and-lchab-color-spaces","title":"LAB and LCHab color spaces","text":"<ul> <li>LABColorSpaces</li> <li>LCHabColorSpaces</li> </ul> <p>LAB and LCHab models each have multiple color spaces that are defined relative to a white point. The default white point is D65.</p>"},{"location":"colorspaces/#cie-luv-and-lchuv","title":"CIE L*u*v* and LCH<sub>uv</sub>","text":"<ul> <li>LUV</li> </ul> Component Description Range L lightness <code>[0, 100]</code> u <code>[-100, 100]</code> v <code>[-100, 100]</code> <ul> <li>LCHuv</li> </ul> Component Description Range L lightness <code>[0, 100]</code> c chroma <code>[0, 100]</code> h hue, degrees, <code>NaN</code> for monochrome colors <code>[0, 360)</code> <p>LUV is a color model intended to be perceptually uniform. Its cylindrical representation is LCH<sub>uv</sub>.</p>"},{"location":"colorspaces/#luv-and-lchuv-color-spaces","title":"LUV and LCHuv color spaces","text":"<ul> <li>LUVColorSpaces</li> <li>LCHuvColorSpaces</li> </ul> <p>LUV and LCHuv models each have multiple color spaces that are defined relative to a white point. The default white point is D65.</p>"},{"location":"colorspaces/#oklab-and-oklch","title":"Oklab and Oklch","text":"<ul> <li>Oklab</li> </ul> Component Description Range L lightness <code>[0, 1]</code> a green-red <code>[-0.4, 0.4]</code> b blue-yellow <code>[-0.4, 0.4]</code> <ul> <li>Oklch</li> </ul> Component Description Range L lightness <code>[0, 1]</code> c chroma <code>[0, 0.4]</code> h hue, degrees, <code>NaN</code> for monochrome colors <code>[0, 360)</code> <p>Oklab is a perceptual color space for image processing. Its cylindrical representation is Oklch.</p>"},{"location":"colorspaces/#cie-xyz","title":"CIE XYZ","text":"<ul> <li>XYZ</li> </ul> Component Range X <code>[0, 1]</code> Y <code>[0, 1]</code> Z <code>[0, 1]</code> <p>The XYZ color model is common used as a profile connection space when converting between other models.</p>"},{"location":"colorspaces/#xyz-color-spaces","title":"XYZ color spaces","text":"<ul> <li>XYZColorSpaces</li> </ul> <p>The XYZ model has multiple color spaces that are defined relative to a white point. The default white point is D65.</p>"},{"location":"colorspaces/#ansi-color-codes","title":"ANSI color codes","text":"<ul> <li>ANSI16</li> <li>ANSI256</li> </ul> <p>Based on the VGA color palette, there are models for 4-bit, 16 color codes and 8-bit, 256 color codes</p>"},{"location":"colorspaces/#cmyk","title":"CMYK","text":"<ul> <li>CMYK</li> </ul> Component Description Range c cyan <code>[0, 1]</code> m magenta <code>[0, 1]</code> y yellow <code>[0, 1]</code> k key / black <code>[0, 1]</code> <p>Colormath\u2019s CMYK model uses device-independent conversions. Device CMYK profiles are not currently supported.</p>"},{"location":"extensions/","title":"Colormath extensions","text":"<p>Colormath provides extensions for converting to and from other platform\u2019s color representations. Each set of extensions is published as a separate maven package.</p>"},{"location":"extensions/#android-colorint","title":"Android ColorInt","text":"<pre><code>dependencies {\n    implementation(\"com.github.ajalt.colormath:colormath-ext-android-colorint:$colormathVersion\")\n}\n</code></pre> <p>API docs</p> <p>These extensions convert between Android\u2019s packed ARGB integers, which are commonly annotated with <code>@ColorInt</code>.</p> <p>This package supports Android API 16+.</p> <pre><code>val redPercent = RGBInt.fromColorInt(textView.currentTextColor).redFloat\nval textColor = RGB.fromColorInt(textView.currentTextColor)\ntextView.highlightColor = textColor.toColorInt()\n</code></pre>"},{"location":"extensions/#android-color-objects","title":"Android Color objects","text":"<pre><code>dependencies {\n    implementation(\"com.github.ajalt.colormath:colormath-ext-android-color:$colormathVersion\")\n}\n</code></pre> <p>API docs</p> <p>These extensions convert between the color objects introduced in Android 26.</p> <p>This package supports Android API 26+.</p> <pre><code>import android.graphics.ColorSpace\nimport android.graphics.Color as AndroidColor\n\nval c: AndroidColor = RGB(\"#f0f\").toAndroidColor()\nval rgb: RGB = c.toColormathSRGB()\nval lab = AndroidColor.valueOf(0f, 1f, 0f, 1f, ColorSpace.get(ColorSpace.Named.CIE_LAB)).toColormathColor()\n</code></pre>"},{"location":"extensions/#jetpack-compose-color-objects","title":"Jetpack Compose Color objects","text":"<pre><code>dependencies {\n    implementation(\"com.github.ajalt.colormath:colormath-ext-jetpack-compose:$colormathVersion\")\n}\n</code></pre> <p>API docs</p> <p>These extensions convert between the color objects used in <code>androidx.compose</code>.</p> <p>This package supports Android API 21+.</p>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#creating-colors","title":"Creating colors","text":"<p>Instances of a color are constructed by invoking their color model.</p> <pre><code>LAB(50, 75, 100)\n</code></pre> <p>For models with multiple color spaces, you can also invoke the specific color space, or create your own:</p> <pre><code>LAB50(50, 75, 100) // Uses the D50 illuminant\nval LAB55 = LabColorSpace(Illuminant.D55)\nLAB55(10, 20, 30)\n</code></pre> <p>You can optionally specify an alpha value.</p> <pre><code>LAB(l=0, a=0, b=0, alpha=0.5)\n</code></pre> <p>If you don\u2019t specify an alpha value, it will default to 1, meaning fully opaque. </p> <p>sRGB colors can also be constructed from hex strings or integers. All of the following are equivalent:</p> <pre><code>RGB(0.2, 0.4, 0.6)\nSRGB(0.2, 0.4, 0.6)\nRGB.from255(51, 102, 153)\nRGB(\"#369\")\nRGB(\"#336699\")\nRGBInt(0x336699u).toSRGB()\n</code></pre> <p>You can find the full list of built-in color spaces here.</p>"},{"location":"usage/#converting-colors","title":"Converting colors","text":"<p>You can convert a color to another color space with any of the Color.to*() functions:</p> <pre><code>RGB(\"#111\").toHSL()\nXYZ(.1, .2, .3).toOklab()\n</code></pre> <p>You can also convert to a specific color space with convertTo:</p> <pre><code>RGB(\"#111\").convertTo(LinearSRGB)\nRGB(\"#222\").convertTo(LAB)\nRGB(\"#333\").convertTo(LAB50)\n</code></pre> <p>If you need to convert multiple colors from one RGB color space to another, you can use an RGBToRGBConverter, which is more efficient than using <code>convertTo</code> multiple times:</p> <pre><code>val srgbColors: List&lt;RGB&gt; = listOf(/*...*/)\nval converter = SRGB.converterTo(ACES)\nval acesColors = srgbColors.map { converter.convert(it) } \n</code></pre> <p>Caution</p> <p>When converting to polar spaces like <code>HSL</code>, the hue is undefined for grayscale colors. When that\u2019s the case, the hue value will be <code>NaN</code>. If you always want a non-NaN hue, you can use hueOr like <code>hsl.hueOr(0)</code>.</p> <p>Read more about why the hue can be NaN here</p>"},{"location":"usage/#color-transforms","title":"Color transforms","text":"<p>You can create generic transforms for colors with Color.map. Colormath includes several built-in transforms.</p>"},{"location":"usage/#mix","title":"Mix","text":"<p>Mix two colors based on a fraction of each, with a syntax that\u2019s similar to the CSS color-mix function.</p> <pre><code>val purple = LCHab(29, 66, 327)\nval plum = LCHab(73, 37, 324)\nval mixed = LCHab.mix(purple, .8, plum, .3)\n</code></pre> <p>Note</p> <p>If the amount of the two colors adds up to less than one, the resulting mix will be partially transparent. </p>"},{"location":"usage/#interpolate","title":"Interpolate","text":"<p>You can also interpolate between two colors. This is similar to <code>mix</code>, but takes a single parameter <code>t</code> indicating the amount to interpolate between the two colors, with <code>t=0</code> returning the first color, and <code>t=1</code> returning the second.</p> <pre><code>val color1 = RGB(\"#000\")\nval color2 = RGB(\"#444\")\ncolor1.interpolate(color2, t=0.25)\n// RGB(\"#111\")\n</code></pre>"},{"location":"usage/#premultiply-alpha","title":"Premultiply alpha","text":"<p>Colormath colors aren\u2019t normally stored with alpha premultiplied. You can do so with multiplyAlpha, and revert the operation with divideAlpha.</p> <pre><code>val color = RGB(1, 1, 1, alpha = 0.25)\ncolor.multiplyAlpha()\n// RGB(0.25, 0.25, 0.25, alpha=0.25)\n</code></pre>"},{"location":"usage/#color-calculations","title":"Color calculations","text":""},{"location":"usage/#color-gamut","title":"Color gamut","text":"<p>You can check if a color is within the sRGB gamut with isInSRGBGamut.</p> <pre><code>XYZ(.5, .7, 1).isInSRGBGamut() // true\nICtCp(0, .5, .5).isInSRGBGamut() // false\n</code></pre>"},{"location":"usage/#color-contrast","title":"Color contrast","text":"<p>You can calculate the relative luminance of a color, or the contrast between two colors according to the Web Content Accessibility Guidelines.</p> <pre><code>RGB(\"#f3a\").wcagLuminance() // 0.26529932\nRGB(\"#aaa\").wcagContrastRatio(RGB(\"#fff\")) // 2.323123\n</code></pre> <p>You can also select the most contrasting color from a list of colors, similar to the CSS <code>color-contrast</code> function.</p> <pre><code>val wheat = RGB(\"#f5deb3\")\nval tan = RGB(\"#d2b48c\")\nval sienna = RGB(\"#a0522d\")\nval accent = RGB(\"#b22222\")\nwheat.mostContrasting(tan, sienna, accent) // returns accent\n</code></pre> <p>In addition to mostContrasting, you can use firstWithContrast or firstWithContrastOrNull, depending on your use case.</p>"},{"location":"usage/#color-difference","title":"Color difference","text":"<p>Colormath includes several formulas for computing the relative perceptual difference between two colors.</p> <ul> <li>euclideanDistance</li> <li>differenceCIE76</li> <li>differenceCIE94</li> <li>differenceCIE2000</li> <li>differenceCMC</li> <li>differenceEz</li> </ul>"},{"location":"usage/#gradients-and-interpolation","title":"Gradients and Interpolation","text":"<p>For gradients and advanced interpolation, you can use the interpolator builder. </p> <pre><code>// You can interpolate in any color space.\nval interp = Oklab.interpolator { \n    // Color stops can be specified in a different space than the interpolator\n    stop(RGB(\"#00f\"))\n    stop(RGB(\"#fff\"))\n    stop(RGB(\"#000\"))\n}\n\n// Get a single color\ninterp.interpolate(0.25)\n\n// Or a sequence of colors to draw a gradient\nfor ((x, color) in interp.sequence(canvas.width).withIndex()) {\n    canvas.drawRect(x=x, y=0, w=1, h=canvas.height, color)\n}\n</code></pre>"},{"location":"usage/#interpolation-method","title":"Interpolation method","text":"<p>Interpolators use linear interpolation by default. Colormath also includes an implementation of monotone spline interpolation, which produces smoother gradients.</p> <pre><code>LCHab.interpolator { \n    method = InterpolationMethods.monotoneSpline()\n    // ...\n}\n</code></pre>"},{"location":"usage/#easing-functions","title":"Easing functions","text":"<p>Where the interpolation method changes the path the gradient takes through a color space, an easing function changes the speed that the path is traversed.</p> <p>EasingFunctions includes all the CSS easing functions, as well as an easing function to set the midpoint of the gradient between two stops.</p> <pre><code>LCHab.interpolator {\n    // Set the easing function for all components\n    easing = EasingFunctions.easeInOut()\n    // Override the easing function for a specific component\n    componentEasing(\"h\", EasingFunctions.linear())\n\n    stop(RGB(\"#00f\")) {\n        // Override the easing function between this stop and the next\n        easing = EasingFunctions.midpoint(.25)\n    }\n    stop(RGB(\"#fff\"))\n    stop(RGB(\"#000\"))\n}\n</code></pre>"},{"location":"usage/#component-adjustment","title":"Component adjustment","text":"<p>You can make adjustments to the values of a component prior to interpolation. The CSS standard calls this a \u201cfixup\u201d. </p>"},{"location":"usage/#alpha-adjustment","title":"Alpha adjustment","text":"<p>By default, if any color stops have an alpha value specified, any other stop with an unspecified alpha will have their alphas set to 1.</p>"},{"location":"usage/#hue-adjustment","title":"Hue adjustment","text":"<p>When interpolating in a cylindrical space like LCH<sub>ab</sub>, there are multiple ways to interpolate the hue (do you travel clockwise or counterclockwise around the hue circle?). You can pick a strategy from HueAdjustments, which contains all the methods defined in the CSS standard. By default, HueAdjustments.shorter is used.</p> <pre><code>LCHab.interpolator {\n    // set the adjustment for the hue\n    componentAdjustment(\"h\", HueAdjustments.longer)\n    // disable the default alpha adjustment\n    componentAdjustment(\"alpha\") { it }\n\n    // ...\n}\n</code></pre>"},{"location":"usage/#chromatic-adaptation","title":"Chromatic adaptation","text":"<p>When converting between color spaces that use different white points, the color is automatically adapted using Von Kries\u2019 method with the CIECAM02 CAT matrix. If you\u2019d like to perform chromatic adaptation using a different matrix (such as Bradford\u2019s), you can convert the color to XYZ and use adaptTo.</p> <pre><code>val bradfords = floatArrayOf(\n     0.8951f,  0.2664f, -0.1614f,\n    -0.7502f,  1.7135f,  0.0367f,\n     0.0389f, -0.0685f,  1.0296f,\n)\n// adapt this color to LAB with a D50 whitepoint using bradford's matrix\nRGB(\"#f3a\").toXYZ().adaptTo(XYZ50, bradfords).toLAB()\n// LAB50(l=59.029217, a=79.97541, b=-14.047905)\n</code></pre> <p>If you want to adapt multiple colors at once based on a source white color, you can use createChromaticAdapter.</p> <pre><code>val sourceWhite : Color = bitmap.getWhitestPixel()\nval adapter = RGBInt.createChromaticAdapter(sourceWhite)\nval pixels : IntArray = bitmap.getArgbPixels()\nadapter.adaptAll(pixels)\nbitmap.setPixels(pixels)\n</code></pre>"},{"location":"usage/#parsing-color-strings","title":"Parsing color strings","text":"<p>You can create a <code>Color</code> instance from any CSS color string using parse and parseOrNull.</p> <pre><code>Color.parse(\"red\") // RGB(r=1.0, g=0.0, b=0.0)\nColor.parse(\"rgb(51 102 51 / 40%)\") // RGB(r=0.2, g=0.4, b=0.2, alpha=0.4)\nColor.parse(\"hwb(200grad 20% 45%)\") // HWB(h=180.0, w=0.2, b=0.45)\n</code></pre>"},{"location":"usage/#rendering-colors-as-strings","title":"Rendering colors as strings","text":"<p>You can also render any <code>Color</code> as a CSS color string with formatCssString. Colormath supports more color spaces than CSS, so formatting <code>formatCssString</code> will produce a <code>color()</code> style string with a dashed identifier name based on the color space. </p> <p>You can also use formatCssStringOrNull which will return null when called on a color space that isn\u2019t built in to CSS.</p> <p>To render a color as a hex string, convert it to sRGB and use toHex.</p> <pre><code>RGB(.2, 0, 1, alpha = .5).formatCssString() // \"rgb(51 0 255 / 0.5)\"\nLCHab50(50, 10, 180).formatCssString() // \"lch(50% 10 180)\"\nROMM_RGB(.1, .2, .4).formatCssString() // \"color(prophoto-rgb 0.1 0.2 0.4)\"\nRGB(.2, .4, .6).toHex() // \"#336699\"\n</code></pre> <p>Caution</p> <p>The CSS <code>lab</code>, <code>lch</code>, and <code>xyz</code> functions specify colors with the D50 illuminant. Colormath\u2019s default constructors for those color spaces use D65, so they will be subject to chromatic adaptation before rendering. To avoid this, use the D50 versions of the constructors: LAB50, LCHab50, and XYZ50</p>"},{"location":"usage/#why-can-a-hue-be-nan","title":"Why can a hue be <code>NaN</code>?","text":"<p>Cylindrical color spaces like <code>HSL</code> and <code>HSV</code> represent their hue as an angle in a hue circle.</p> <p> </p> <p>The HSV hue circle, from wikimedia</p> <p>But for monochrome colors like white and grey, the hue value is undefined. If the color is grey, we can use any value for the hue and the color will be unchanged.</p> <pre><code>HSV(0, 0, .5).toSRGB().toHex()   // #808080\nHSV(123, 0, .5).toSRGB().toHex() // #808080\n</code></pre> <p>So colormath sets the hue to <code>NaN</code> when it\u2019s undefined. Why not use a regular number like 0? Let\u2019s say we want to make a gradient from white to cyan.</p> <p>0\u00b0 hue is red, so if we use a value of 0 as the hue for white, the gradient will interpolate the hue from 0 to 180, sweeping through the hues from red to cyan:</p> <pre><code>HSV.interpolator {\n    stop(HSV(0, 0, 1))\n    stop(HSV(180, 1, 1))\n}\n</code></pre> <p></p> <p>If we instead use <code>NaN</code> for the white hue, the gradient will keep the interpolated hue constant, resulting in the gradient we expect:</p> <pre><code>HSV.interpolator {\n    stop(HSV(NaN, 0, 1))\n    stop(HSV(180, 1, 1))\n}\n</code></pre> <p></p>"}]}